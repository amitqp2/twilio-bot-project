import logging
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler
from twilio.rest import Client
import os # <--- ржПржЗ рж▓рж╛ржЗржиржЯрж┐ ржирждрзБржи ржпрзЛржЧ рж╣рзЯрзЗржЫрзЗ ржмрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржпрзЗ ржПржЯрж┐ ржЖржЫрзЗ

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Globals
user_sessions = {}  # user_id -> {'sid': str, 'auth': str, 'client': Client, 'number': str}

# State for ConversationHandler
LOGIN_AWAITING_CREDENTIALS = range(1)

# ---- English Menu Texts with Emojis (Standard Font) ----
LOGIN_TEXT = 'ЁЯФС Login'
BUY_TEXT = 'ЁЯЫТ Buy Number'
SHOW_MESSAGES_TEXT = 'тЬЙя╕П Show Messages'
REMOVE_NUMBER_TEXT = 'ЁЯЧСя╕П Remove Number'
LOGOUT_TEXT = 'тЖкя╕П Logout'

# Persistent menu - Updated with English texts and emojis
menu_keyboard = [
    [LOGIN_TEXT],
    [BUY_TEXT, SHOW_MESSAGES_TEXT, REMOVE_NUMBER_TEXT],
    [LOGOUT_TEXT]
]
reply_markup = ReplyKeyboardMarkup(menu_keyboard, resize_keyboard=True, one_time_keyboard=False)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"ЁЯСЛ рж╕рзНржмрж╛ржЧрждржо! рж╢рзБрж░рзБ ржХрж░рждрзЗ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрж╛ржкрзБржи ржЕржержмрж╛ ржорзЗржирзБ ржерзЗржХрзЗ ржЕржирзНржп ржХрзЛржирзЛ ржЕржкрж╢ржи ржмрзЗржЫрзЗ ржирж┐ржиред", reply_markup=reply_markup)

async def login_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in user_sessions:
        await update.message.reply_text("тЬЕ ржЖржкржирж┐ ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж▓ржЧржЗржи ржХрж░рж╛ ржЖржЫрзЗржиред", reply_markup=reply_markup)
        return ConversationHandler.END
    await update.message.reply_text("ЁЯУЭ ржЖржкржирж╛рж░ Twilio Account SID ржПржмржВ Auth Token ржПржЦрж╛ржирзЗ ржжрж┐ржи, ржПржХржЯрж┐ рж╕рзНржкрзЗрж╕ ржжрж┐рзЯрзЗ ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ (ржпрзЗржоржи: <SID>space<AUTH_TOKEN> ):")
    return LOGIN_AWAITING_CREDENTIALS

async def receive_credentials(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    try:
        sid, auth = update.message.text.strip().split(maxsplit=1)
        client = Client(sid, auth)
        client.api.accounts(sid).fetch() # Validate credentials
        user_sessions[user_id] = {'sid': sid, 'auth': auth, 'client': client, 'number': None}
        await update.message.reply_text("ЁЯОЙ рж▓ржЧржЗржи рж╕ржлрж▓ рж╣рзЯрзЗржЫрзЗ!", reply_markup=reply_markup)
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Login failed for user {user_id}: {e}")
        await update.message.reply_text(f"тЭМ ржЖржкржирж╛рж░ ржжрзЗржУрзЯрж╛ SID ржПржмржВ Auth Token ржжрж┐рзЯрзЗ рж▓ржЧржЗржи ржХрж░рждрзЗ ржмрзНржпрж░рзНрже рж╣рзЯрзЗржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрзЗржкрзЗ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
        return ConversationHandler.END

async def logout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
        await update.message.reply_text("тЬЕ ржЖржкржирж┐ рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓ржЧ ржЖржЙржЯ рж╣рзЯрзЗржЫрзЗржиред", reply_markup=reply_markup)
    else:
        await update.message.reply_text("тД╣я╕П ржЖржкржирж┐ рж▓ржЧржЗржи ржЕржмрж╕рзНржерж╛рзЯ ржирзЗржЗред", reply_markup=reply_markup)

async def buy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    
    client = user_sessions[user_id]['client']
    try:
        available_numbers = client.available_phone_numbers("CA").local.list(limit=10) 
        if not available_numbers:
            await update.message.reply_text("ЁЯШФ ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржХрзЛржирзЛ ржЙржкрж▓ржнрзНржп ржиржорзНржмрж░ ржирзЗржЗред")
            return

        keyboard = []
        for number_obj in available_numbers: # renamed 'number' to 'number_obj' to avoid conflict
            button_text = f"ЁЯЫТ ржХрж┐ржирзБржи {number_obj.phone_number}"
            callback_data = f"purchase_{number_obj.phone_number}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        
        if not keyboard:
             await update.message.reply_text("ЁЯШФ ржиржорзНржмрж░ ржкрж╛ржУрзЯрж╛ ржЧрзЗрж▓рзЗржУ ржмрж╛ржЯржи рждрзИрж░рж┐ ржХрж░рж╛ ржпрж╛рзЯржирж┐ред")
             return

        inline_reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("ЁЯУЮ ржЙржкрж▓ржмрзНржз ржиржорзНржмрж░ ржирж┐ржЪрзЗ ржжрзЗржУрзЯрж╛ рж╣рж▓рзЛред ржкржЫржирзНржжрзЗрж░ ржиржорзНржмрж░рзЗрж░ ржкрж╛рж╢рзЗрж░ 'ржХрж┐ржирзБржи' ржмрж╛ржЯржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзБржи:", reply_markup=inline_reply_markup)

    except Exception as e:
        logger.error(f"Failed to fetch numbers for user {user_id}: {e}")
        await update.message.reply_text("тЪая╕П ржиржорзНржмрж░ ржЖржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред рж╕ржорзНржнржмржд ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржПржЗ ржЕржЮрзНржЪрж▓рзЗрж░ ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБржорждрж┐ ржирзЗржЗ ржЕржержмрж╛ ржЕржирзНржп ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ред")

async def purchase_number_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer() 

    user_id = query.from_user.id
    
    if user_id not in user_sessions:
        await query.edit_message_text(text=f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return

    if user_sessions[user_id].get('number'):
        current_number = user_sessions[user_id]['number']
        await query.edit_message_text(text=f"тД╣я╕П ржЖржкржирж╛рж░ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржПржХржЯрж┐ ржиржорзНржмрж░ ({current_number}) ржХрзЗржирж╛ ржЖржЫрзЗред ржирждрзБржи ржиржорзНржмрж░ ржХрж┐ржирждрзЗ ржЖржЧрзЗрж░ржЯрж┐ '{REMOVE_NUMBER_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржорзБржЫрзБржиред")
        return

    try:
        action, number_to_buy = query.data.split('_', 1)
        if action != "purchase" or not number_to_buy.startswith('+'): 
            logger.warning(f"Invalid callback data format: {query.data} for user {user_id}")
            await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБрж░рзЛржзрзЗ рждрзНрж░рзБржЯрж┐ рж╣рзЯрзЗржЫрзЗред")
            return
    except ValueError:
        logger.warning(f"Callback data splitting error: {query.data} for user {user_id}")
        await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБрж░рзЛржз ржмрзБржЭрждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред")
        return

    client = user_sessions[user_id]['client']
    try:
        logger.info(f"User {user_id} attempting to purchase number: {number_to_buy}")
        incoming_number = client.incoming_phone_numbers.create(phone_number=number_to_buy)
        user_sessions[user_id]['number'] = incoming_number.phone_number # Store the purchased number object's phone_number
        success_message = f"ЁЯЫНя╕П ржиржорзНржмрж░ {incoming_number.phone_number} рж╕ржлрж▓ржнрж╛ржмрзЗ ржХрзЗржирж╛ рж╣рзЯрзЗржЫрзЗ!"
        await query.edit_message_text(text=success_message, reply_markup=None)
    except Exception as e:
        logger.error(f"Failed to buy number {number_to_buy} for user {user_id}: {e}")
        error_message = f"тЭМ ржПржЗ ржиржорзНржмрж░ржЯрж┐ ({number_to_buy}) ржХрж┐ржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред"
        if "violates a uniqueness constraint" in str(e).lower() or "already provisioned" in str(e).lower():
            error_message += " ржПржЯрж┐ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ рж░рзЯрзЗржЫрзЗ ржЕржержмрж╛ ржЕржирзНржп ржХрзЗржЙ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрзЗред"
        elif "not be found" in str(e).lower() or "not available" in str(e).lower(): 
            error_message += " ржиржорзНржмрж░ржЯрж┐ ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржЖрж░ ржЙржкрж▓ржмрзНржз ржирзЗржЗред"
        else:
            error_message += " ржПржЯрж┐ ржЙржкрж▓ржмрзНржз ржирж╛ржУ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗ ржЕржержмрж╛ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржкрж░рзНржпрж╛ржкрзНржд ржмрзНржпрж╛рж▓рзЗржирзНрж╕/ржЕржирзБржорждрж┐ ржирзЗржЗред"
        await query.edit_message_text(text=error_message, reply_markup=None)

async def show_messages_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    if not user_sessions[user_id].get('number'):
        await update.message.reply_text(f"тД╣я╕П ржЖржкржирж╛рж░ ржХрзЛржирзЛ ржХрзЗржирж╛ ржиржорзНржмрж░ ржирзЗржЗред ржкрзНрж░ржержорзЗ '{BUY_TEXT}' ржПрж░ ржорж╛ржзрзНржпржорзЗ ржПржХржЯрж┐ ржиржорзНржмрж░ ржХрж┐ржирзБржиред")
        return
    
    client = user_sessions[user_id]['client']
    twilio_number_str = user_sessions[user_id]['number'] # Renamed to avoid conflict
    try:
        messages = client.messages.list(to=twilio_number_str, limit=5)
        if not messages:
            await update.message.reply_text("ЁЯУк ржЖржкржирж╛рж░ ржПржЗ ржиржорзНржмрж░рзЗ ржХрзЛржирзЛ ржорзЗрж╕рзЗржЬ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
        else:
            response_msg = "ЁЯУи ржЖржкржирж╛рж░ ржиржорзНржмрж░рзЗ ржЖрж╕рж╛ рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ ржорзЗрж╕рзЗржЬ:\n"
            for msg_instance in messages:
                response_msg += f"From: {msg_instance.from_}\nBody: {msg_instance.body}\n---\n"
            await update.message.reply_text(response_msg)
    except Exception as e:
        logger.error(f"Failed to fetch messages for user {user_id} on number {twilio_number_str}: {e}")
        await update.message.reply_text("тЪая╕П ржорзЗрж╕рзЗржЬ ржЖржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред")

async def remove_number_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    
    active_number = user_sessions[user_id].get('number')
    if not active_number:
        await update.message.reply_text("тД╣я╕П ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ рж░рж┐ржорзБржн ржХрж░рж╛рж░ ржорждрзЛ ржХрзЛржирзЛ рж╕ржХрзНрж░рж┐рзЯ ржиржорзНржмрж░ ржирзЗржЗред")
        return

    confirmation_message = f"тД╣я╕П ржЖржкржирж╛рж░ ржмрж░рзНрждржорж╛ржирзЗ ржХрзЗржирж╛ ржиржорзНржмрж░ржЯрж┐ рж╣рж▓рзЛ: {active_number}ред ржЖржкржирж┐ ржХрж┐ ржПржЗ ржиржорзНржмрж░ржЯрж┐ рж░рж┐ржорзБржн ржХрж░рждрзЗ ржирж┐рж╢рзНржЪрж┐ржд?"
    keyboard = [[
        InlineKeyboardButton("тЬЕ рж╣рзНржпрж╛ржБ, ржирж┐рж╢рзНржЪрж┐ржд", callback_data="confirm_remove_yes"),
        InlineKeyboardButton("тЭМ ржирж╛, ржмрж╛рждрж┐рж▓", callback_data="confirm_remove_no")
    ]]
    inline_reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(confirmation_message, reply_markup=inline_reply_markup)

async def confirm_remove_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    action = query.data

    if user_id not in user_sessions or not user_sessions[user_id].get('number'):
        await query.edit_message_text(text="ЁЯЪл ржПржЗ ржЕржирзБрж░рзЛржзржЯрж┐ ржЖрж░ ржмрзИржз ржирзЯ ржЕржержмрж╛ ржЖржкржирж╛рж░ рж▓ржЧржЗржи рж╕рзЗрж╢ржи ржмрж╛ рж╕ржХрзНрж░рж┐рзЯ ржиржорзНржмрж░ ржирзЗржЗред")
        return

    number_to_remove = user_sessions[user_id]['number']

    if action == "confirm_remove_yes":
        client = user_sessions[user_id]['client']
        try:
            logger.info(f"User {user_id} confirmed removal for number: {number_to_remove}")
            incoming_phone_numbers = client.incoming_phone_numbers.list(phone_number=number_to_remove, limit=1)
            if not incoming_phone_numbers:
                await query.edit_message_text(text=f"тЭУ ржиржорзНржмрж░ {number_to_remove} ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред")
                user_sessions[user_id]['number'] = None 
                return

            number_sid = incoming_phone_numbers[0].sid
            client.incoming_phone_numbers(number_sid).delete()
            user_sessions[user_id]['number'] = None
            await query.edit_message_text(text=f"ЁЯЧСя╕П ржиржорзНржмрж░ {number_to_remove} рж╕ржлрж▓ржнрж╛ржмрзЗ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ!")
        except Exception as e:
            logger.error(f"Failed to remove number {number_to_remove} for user {user_id} after confirmation: {e}")
            await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ рж░рж┐ржорзБржн ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред")
    
    elif action == "confirm_remove_no":
        await query.edit_message_text(text="ЁЯЪл ржиржорзНржмрж░ рж░рж┐ржорзБржн ржХрж░рж╛рж░ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред")


async def handle_general_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()

    if user_id in user_sessions and text.startswith('+') and user_sessions[user_id].get('client'):
        number_to_buy = text
        client = user_sessions[user_id]['client']
        if user_sessions[user_id].get('number'):
            await update.message.reply_text(f"тД╣я╕П ржЖржкржирж╛рж░ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржПржХржЯрж┐ ржиржорзНржмрж░ ({user_sessions[user_id]['number']}) ржХрзЗржирж╛ ржЖржЫрзЗред ржирждрзБржи ржиржорзНржмрж░ ржХрж┐ржирждрзЗ ржЖржЧрзЗрж░ржЯрж┐ '{REMOVE_NUMBER_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржорзБржЫрзБржиред")
            return
        try:
            incoming_number = client.incoming_phone_numbers.create(phone_number=number_to_buy)
            user_sessions[user_id]['number'] = incoming_number.phone_number
            await update.message.reply_text(f"ЁЯЫНя╕П ржиржорзНржмрж░ {incoming_number.phone_number} рж╕ржлрж▓ржнрж╛ржмрзЗ ржХрзЗржирж╛ рж╣рзЯрзЗржЫрзЗред (ржорзНржпрж╛ржирзБрзЯрж╛рж▓)", reply_markup=reply_markup)
        except Exception as e:
            logger.error(f"Failed to buy number {number_to_buy} for user {user_id} via general text: {e}")
            error_message = "тЭМ ржПржЗ ржиржорзНржмрж░ржЯрж┐ ржХрж┐ржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред (ржорзНржпрж╛ржирзБрзЯрж╛рж▓)"
            if "violates a uniqueness constraint" in str(e).lower() or "already provisioned" in str(e).lower():
                error_message = f"тЪая╕П ржиржорзНржмрж░ {number_to_buy} ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ рж░рзЯрзЗржЫрзЗ ржЕржержмрж╛ ржЕржирзНржп ржХрзЗржЙ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрзЗред (ржорзНржпрж╛ржирзБрзЯрж╛рж▓)"
            elif "AreaCode is required for an address-based search" in str(e):
                 error_message = "тД╣я╕П ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЬржирзНржп ржПрж░рж┐рзЯрж╛ ржХрзЛржбрж╕рж╣ ржиржорзНржмрж░ ржжрж┐ржи ржЕржержмрж╛ ржЙржкрж▓ржнрзНржп ржиржорзНржмрж░ рждрж╛рж▓рж┐ржХрж╛ ржерзЗржХрзЗ ржмрж╛ржЫрж╛ржЗ ржХрж░рзБржиред (ржорзНржпрж╛ржирзБрзЯрж╛рж▓)"
            await update.message.reply_text(error_message)
    else:
        pass


if __name__ == '__main__':
    # TOKEN ржПржиржнрж╛рзЯрж░ржиржорзЗржирзНржЯ ржнрзЗрж░рж┐рзЯрзЗржмрж▓ ржерзЗржХрзЗ рж▓рзЛржб ржХрж░рж╛ рж╣ржмрзЗ
    TOKEN = os.environ.get("8112724490:AAHVK5H6iJZgeHvV0_2Meyu4kODO9YfTdqU")
    if TOKEN is None:
        # logger ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ: logger.critical("ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯ ржЯрзЛржХрзЗржи (TELEGRAM_BOT_TOKEN) ржПржиржнрж╛рзЯрж░ржиржорзЗржирзНржЯ ржнрзЗрж░рж┐рзЯрзЗржмрж▓рзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐!")
        print("рждрзНрж░рзБржЯрж┐: TELEGRAM_BOT_TOKEN ржирж╛ржоржХ ржПржиржнрж╛рзЯрж░ржиржорзЗржирзНржЯ ржнрзЗрж░рж┐рзЯрзЗржмрж▓ рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ!")
        exit() # ржЯрзЛржХрзЗржи ржирж╛ ржкрзЗрж▓рзЗ ржмржЯ ржЪрж╛рж▓рзБ рж╣ржмрзЗ ржирж╛
    
    app = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Text([LOGIN_TEXT]), login_command_handler)],
        states={
            LOGIN_AWAITING_CREDENTIALS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_credentials)]
        },
        fallbacks=[] 
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("start", start))

    app.add_handler(MessageHandler(filters.Text([LOGOUT_TEXT]), logout_handler))
    app.add_handler(MessageHandler(filters.Text([BUY_TEXT]), buy_handler)) 
    app.add_handler(MessageHandler(filters.Text([REMOVE_NUMBER_TEXT]), remove_number_handler))
    app.add_handler(MessageHandler(filters.Text([SHOW_MESSAGES_TEXT]), show_messages_handler))
    
    app.add_handler(CallbackQueryHandler(purchase_number_callback_handler, pattern='^purchase_'))
    app.add_handler(CallbackQueryHandler(confirm_remove_callback_handler, pattern='^confirm_remove_(yes|no)$'))
    
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_general_text))

    logger.info("ЁЯдЦ Bot starting to poll...")
    app.run_polling()
